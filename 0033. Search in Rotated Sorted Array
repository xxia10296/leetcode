

33. Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm's runtime complexity must be in the order of O(log n).
Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

https://www.youtube.com/watch?v=7SC0hWGeyBo

Summary: - Suggest time O(log n), so we use binary search. Even though array is rotated, there must be one half
           of the array is sorted.
           
  case1       7 0 1 |2| 4 5 6           num[mid] is 2, the right side 4 5 6 is sorted
  case2       4 5 6 |7| 8 1 2           num[mid] is 7, the left side 4 5 6 is sorted
         num[left]  [mid]  num[right]
         
         - the key is to compare num[left] & num[mid]:
          - case 1: num[left] > num[mid], ---> right side is sorted
  (target at sorted)     - if num[mid] < target < num[right], narrow down to search right side. change left = mid +1
                         - if target > num[left] or target <= num[mid], narrow downt to search left side. change right = mid -1
          
          - case 2: num[left] < num[mid], ---> left side is sorted:
  (target at sorted)     - if num[left] < target < num[mid], narrow down to search left. change right = mid-1
                         - if target < num[mid] or target > num[mid], narrow down to search right. change left = mid+1
  Time: O(log n)
  Space: O(1)
  
  var search = function(nums, target) {
  let left = 0;
  let right = nums.length - 1;
    
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    }    
    // Check if the left side is sorted
    if (nums[left] <= nums[mid]) {
      if (nums[left] <= target && target <= nums[mid]) {
        // target is in the left
        right = mid - 1;
        
      } else {
        // target is in the right
        left = mid + 1;
      }
    } 
    
    // Otherwise, the right side is sorted
    else {
      if (nums[mid] <= target && target <= nums[right]) {
        // target is in the right
        left = mid + 1;

      } else {
        // target is in the left
        right = mid - 1;
      }
    }
  }
  return -1;
};
